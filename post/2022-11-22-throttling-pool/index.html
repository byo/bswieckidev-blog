<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Throttling Pool | Just a dev blog</title><meta name=keywords content="go,howto,code"><meta name=description content="In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves."><meta name=author content><link rel=canonical href=https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/><link crossorigin=anonymous href=https://blog.bswiecki.dev/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://blog.bswiecki.dev/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.bswiecki.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.bswiecki.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.bswiecki.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.bswiecki.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.bswiecki.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Throttling Pool"><meta property="og:description" content="In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-11-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Throttling Pool"><meta name=twitter:description content="In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bswiecki.dev/post/"},{"@type":"ListItem","position":2,"name":"Throttling Pool","item":"https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Throttling Pool","name":"Throttling Pool","description":"In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.\nObject pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves.","keywords":["go","howto","code"],"articleBody":"In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.\nObject pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves. There may be many reasons for that. One may want to ensure that the amount of allocated memory does not cross some predefined limit. It may also be the case that frequent allocations and deallocations of memory start causing issues due to a huge CPU cost. Those factors are especially important in more complex systems with tight memory budget such as databases. And it turns out that I had a chance to work with one such database called immudb for more than a year now.\nIn immudb there are some larger scratchpad objects used during the transaction commit that are preallocated when the database is loaded. Once a writer starts preparing a transaction, such scratchpad object is taken from the pool to be returned back to it once the commit finishes.\nSounds familiar? Looks almost identical to the technique used for throttling the number of simultaneous operations with tokens that I presented in the previous post. But instead of fetching a token from the pool that is of no use, we can fetch a useful object. This mechanism is used by immudb to keep the number of simultaneous transactions under control. Without such limit, it would be easy to force the database to use huge amount of resources (which some may refer to as a DoS attack if for example the database runs out of memory).\nThe implementation in immudb is based on a mutex whereas in this blog post I’ll focus on a channel-based implementation that will be similar to what we’ve seen with token-based throttlers.\nPool-throttler Let’s do some exercise now and create such a throttling pool.\nI decided to use generics in the implementation. Instead of creating a pool that works on the interface{} type (or some other concrete one) we can leave the selection of that underlying type to the user of the pool. That way we can avoid a lot of conversions and type assertions ruling out unnecessary casting cost.\nAs with tokens, the core of pool-based throttler will again be a channel:\ntype poolLimiter[T any] struct { ch chan T } In case of token-based throttlers the initialization of such channel was simple because the token type was empty and did not contain any information. In case of a pool, objects in the pool must be initialized correctly. For that reason I decided to add a dedicated initialization functor when creating objects in the pool:\nfunc NewPoolLimiter[T any](poolSize int, gen func() T) PoolLimiter[T] { ret := \u0026poolLimiter[T]{ ch: make(chan T, poolSize), } // Preallocate the pool of objects for i := 0; i \u003c poolSize; i++ { ret.ch \u003c- gen() } return ret } And now the essence of the pool - acquiring and releasing resources. Let’s write few implementations for different use cases, starting with the simplest one.\nBlocking acquire The easiest acquire method to write is the blocking one that will wait until there is at least one object in the pool:\nfunc (p *poolLimiter[T]) Acquire() T { return \u003c-p.ch } Nothing really fancy here - the channel gives us exactly the functionality that we need. But you may also have noticed that contrary to the previous token-based implementations I decided not to return the release function from that method.\nInstead there will be a dedicated Release function in the pool itself:\nfunc (p *poolLimiter[T]) Release(item T) { p.ch \u003c- item } Why such change of the interface? I did some benchmarks and this way the implementation is almost twice as fast (41 ns/op vs 72 ns/op). The overhead of additional function value is pretty significant here. For that reason I also changed the interface of the original token-based throttler (that code even simplified which is usually a good sign).\nAs a side note, the code written so far looks too trivial, isn’t it? Well, it just proves that golang’s built-in primitives are really well designed.\nNon-blocking acquire Let’s move to something a bit more complex now - acquire that will return an error if the pool is empty:\nfunc (p *poolLimiter[T]) AcquireNoWait() (T, error) { var item T select { case item = \u003c-p.ch: return item, nil default: return item, ErrResourceExhausted } } Nothing really fancy here - the built-in select is all we need.\nThe returned item is created and initialized at the beginning of this method which may be a bit surprising. This is needed if the pool is empty. In such case we still have to return some instance of the T type along with an error. Creating a default value initialized at the beginning does the trick.\nContext-aware acquire The most complex (but still fitting in just a few lines of code) is the context-aware acquire:\nfunc (p *poolLimiter[T]) AcquireCtx(ctx context.Context) (T, error) { var item T if ctx.Err() == nil { select { case item = \u003c-p.ch: return item, nil case \u003c-ctx.Done(): break } } return item, ctx.Err() } The code is almost identical to the non-blocking acquire. If the pool is empty and we have to wait for some freed up resources, catching context cancellation with the select built-in allows the function to give up and return an error. Additional if ctx.Err() == nil ensures that we won’t even try to fetch the resource if the context has already been cancelled.\nExercise - token from pool We can try to compare the newly written pool against the older token limiter. For that reason I’ve created a simple wrapper struct encapsulating the pool but exposing the token limiter interface instead:\ntype poolLimiterToTokenLimiter struct { l PoolLimiter[struct{}] } func NewTokenLimiterFromPoolLimiter(maxTokens int) CancellableTokenLimiter { return \u0026poolLimiterToTokenLimiter{ l: NewPoolLimiter(maxTokens, func() struct{} { return struct{}{} }), } } func (l *poolLimiterToTokenLimiter) Acquire() { l.l.Acquire() } func (l *poolLimiterToTokenLimiter) AcquireNoWait() error { _, err := l.l.AcquireNoWait() return err } func (l *poolLimiterToTokenLimiter) AcquireCtx(ctx context.Context) error { _, err := l.l.AcquireCtx(ctx) return err } func (l *poolLimiterToTokenLimiter) Release() { l.l.Release(struct{}{}) } Such implementation was roughly 30% slower than the dedicated token limiter implementation (48.54 ns/op vs 36.90 ns/op). My guess is that this is mostly caused by indirect calls and additional returned value. I think that the gap will become smaller in future versions of the go compiler that will be able to inline functions and detect dead code much better.\nNext The topic of throttling is still not fully explored here so stay tuned for more updates.\nAnd as before, you can find the full source code with all test and benchmarks in Github repository.\n","wordCount":"1152","inLanguage":"en","datePublished":"2022-11-22T00:00:00Z","dateModified":"2022-11-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/"},"publisher":{"@type":"Organization","name":"Just a dev blog","logo":{"@type":"ImageObject","url":"https://blog.bswiecki.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bswiecki.dev/ accesskey=h title="Just a dev blog (Alt + H)">Just a dev blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.bswiecki.dev/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.bswiecki.dev/page/about/ title=About><span>About</span></a></li><li><a href=https://blog.bswiecki.dev/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Throttling Pool</h1><div class=post-meta><span title='2022-11-22 00:00:00 +0000 UTC'>November 22, 2022</span></div></header><div class=post-content><p>In my <a href=https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/>last post</a> I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.</p><h2 id=object-pools-in-go>Object pools in go<a hidden class=anchor aria-hidden=true href=#object-pools-in-go>#</a></h2><p>Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves. There may be many reasons for that. One may want to ensure that the amount of allocated memory does not cross some predefined limit. It may also be the case that frequent allocations and deallocations of memory start causing issues due to a huge CPU cost. Those factors are especially important in more complex systems with tight memory budget such as databases. And it turns out that I had a chance to work with one such database called <a href=https://immudb.io/>immudb</a> for more than a year now.</p><p>In <code>immudb</code> there are some <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/tx.go#L29>larger scratchpad objects</a> used during the transaction commit that are <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L366>preallocated</a> when the database is loaded. Once a writer starts preparing a transaction, such <em>scratchpad</em> object is <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L1217>taken from the pool</a> to be <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L1221>returned back to it</a> once the commit finishes.</p><p>Sounds familiar? Looks almost identical to the technique used for throttling the number of simultaneous operations with tokens that I presented in the <a href=https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/>previous post</a>. But instead of fetching a token from the pool that is of no use, we can fetch a useful object. This mechanism is used by <code>immudb</code> to keep the number of simultaneous transactions <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L1047>under control</a>. Without such limit, it would be easy to <em>force</em> the database to use huge amount of resources (which some may refer to as a <a href=https://en.wikipedia.org/wiki/Denial-of-service_attack>DoS</a> attack if for example the database runs out of memory).</p><p>The implementation in immudb is <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/txpool.go#L39>based on a mutex</a> whereas in this blog post I&rsquo;ll focus on a channel-based implementation that will be similar to what we&rsquo;ve seen with token-based throttlers.</p><h2 id=pool-throttler>Pool-throttler<a hidden class=anchor aria-hidden=true href=#pool-throttler>#</a></h2><p>Let&rsquo;s do some exercise now and create such a throttling pool.</p><p>I decided to use <a href=https://go.dev/doc/tutorial/generics>generics</a> in the implementation. Instead of creating a pool that works on the <code>interface{}</code> type (or some other concrete one) we can leave the selection of that underlying type to the user of the pool. That way we can avoid a lot of conversions and type assertions ruling out unnecessary casting cost.</p><p>As with tokens, the core of pool-based throttler will again be a channel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>poolLimiter</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>] <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In case of token-based throttlers the initialization of such channel was simple because the token type was empty and did not contain any information. In case of a pool, objects in the pool must be initialized correctly. For that reason I decided to add a dedicated initialization functor when creating objects in the pool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewPoolLimiter</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>poolSize</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>gen</span> <span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>PoolLimiter</span>[<span style=color:#a6e22e>T</span>] {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>poolLimiter</span>[<span style=color:#a6e22e>T</span>]{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ch</span>: make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>poolSize</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Preallocate the pool of objects
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>poolSize</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ret</span>.<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>gen</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now the essence of the pool - acquiring and releasing resources. Let&rsquo;s write few implementations for different use cases, starting with the simplest one.</p><h2 id=blocking-acquire>Blocking acquire<a hidden class=anchor aria-hidden=true href=#blocking-acquire>#</a></h2><p>The easiest acquire method to write is the blocking one that will wait until there is at least one object in the pool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiter</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>Acquire</span>() <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ch</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing really fancy here - the channel gives us exactly the functionality that we need. But you may also have noticed that contrary to <a href=https://github.com/byo/go-limiters/blob/v0.1.0/interfaces.go#L15>the previous token-based implementations</a> I decided not to return the release function from that method.</p><p>Instead there will be a dedicated <code>Release</code> function in the pool itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiter</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>Release</span>(<span style=color:#a6e22e>item</span> <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>item</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Why such change of the interface? I did some benchmarks and this way the implementation is almost twice as fast (41 ns/op vs 72 ns/op). The overhead of additional function value is pretty significant here. For that reason I also changed the interface of the original token-based throttler (that code even simplified which is usually a good sign).</p><p>As a side note, the code written so far looks too trivial, isn&rsquo;t it? Well, it just proves that golang&rsquo;s built-in primitives are really well designed.</p><h2 id=non-blocking-acquire>Non-blocking acquire<a hidden class=anchor aria-hidden=true href=#non-blocking-acquire>#</a></h2><p>Let&rsquo;s move to something a bit more complex now - acquire that will return an error if the pool is empty:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiter</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>AcquireNoWait</span>() (<span style=color:#a6e22e>T</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>item</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>item</span> = <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ch</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>item</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>item</span>, <span style=color:#a6e22e>ErrResourceExhausted</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing really fancy here - the built-in <a href=https://go.dev/tour/concurrency/5>select</a> is all we need.</p><p>The returned item is created and initialized at the beginning of this method which may be a bit surprising. This is needed if the pool is empty. In such case we still have to return some instance of the <code>T</code> type along with an error. Creating a default value initialized at the beginning does the trick.</p><h2 id=context-aware-acquire>Context-aware acquire<a hidden class=anchor aria-hidden=true href=#context-aware-acquire>#</a></h2><p>The most complex (but still fitting in just a few lines of code) is the context-aware acquire:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiter</span>[<span style=color:#a6e22e>T</span>]) <span style=color:#a6e22e>AcquireCtx</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>T</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>item</span> <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>item</span> = <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ch</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>item</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>item</span>, <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The code is almost identical to the non-blocking acquire. If the pool is empty and we have to wait for some freed up resources, catching context cancellation with the <a href=https://go.dev/tour/concurrency/5>select</a> built-in allows the function to give up and return an error. Additional <code>if ctx.Err() == nil</code> ensures that we won&rsquo;t even try to fetch the resource if the context has already been cancelled.</p><h2 id=exercise---token-from-pool>Exercise - token from pool<a hidden class=anchor aria-hidden=true href=#exercise---token-from-pool>#</a></h2><p>We can try to compare the newly written pool against the older token limiter. For that reason I&rsquo;ve created a simple wrapper <code>struct</code> encapsulating the pool but exposing the token limiter interface instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>poolLimiterToTokenLimiter</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span> <span style=color:#a6e22e>PoolLimiter</span>[<span style=color:#66d9ef>struct</span>{}]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewTokenLimiterFromPoolLimiter</span>(<span style=color:#a6e22e>maxTokens</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>CancellableTokenLimiter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>poolLimiterToTokenLimiter</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>l</span>: <span style=color:#a6e22e>NewPoolLimiter</span>(<span style=color:#a6e22e>maxTokens</span>, <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>struct</span>{} { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>struct</span>{}{} }),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiterToTokenLimiter</span>) <span style=color:#a6e22e>Acquire</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Acquire</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiterToTokenLimiter</span>) <span style=color:#a6e22e>AcquireNoWait</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>AcquireNoWait</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiterToTokenLimiter</span>) <span style=color:#a6e22e>AcquireCtx</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>AcquireCtx</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>poolLimiterToTokenLimiter</span>) <span style=color:#a6e22e>Release</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Release</span>(<span style=color:#66d9ef>struct</span>{}{})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Such implementation was roughly 30% slower than the dedicated token limiter implementation (48.54 ns/op vs 36.90 ns/op). My guess is that this is mostly caused by indirect calls and additional returned value. I think that the gap will become smaller in future versions of the go compiler that will be able to inline functions and detect dead code much better.</p><h2 id=next>Next<a hidden class=anchor aria-hidden=true href=#next>#</a></h2><p>The topic of throttling is still not fully explored here so stay tuned for more updates.</p><p>And as before, you can find the full source code with all test and benchmarks in <a href=https://github.com/byo/go-limiters/tree/v0.2.0>Github repository</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bswiecki.dev/tags/go/>go</a></li><li><a href=https://blog.bswiecki.dev/tags/howto/>howto</a></li><li><a href=https://blog.bswiecki.dev/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.bswiecki.dev/>Just a dev blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><link href=https://blog.bswiecki.dev/css/mermaid.css type=text/css rel=stylesheet><script defer src=https://blog.bswiecki.dev/js/mermaid.js onload=mermaid.initialize({startOnLoad:!0})></script>
<link href=https://blog.bswiecki.dev/css/katex.css type=text/css rel=stylesheet><script defer src=https://blog.bswiecki.dev/js/katex.js></script>
<script defer src=https://blog.bswiecki.dev/js/katex-auto-render.js onload=renderMathInElement(document.body)></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>