<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Throttling Pool - Just a dev blog</title><meta name=description content="In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves."><meta name=author content="Bartłomiej Święcki"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Just a dev blog","url":"https:\/\/blog.bswiecki.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/blog.bswiecki.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/blog.bswiecki.dev\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/blog.bswiecki.dev\/post\/2022-11-22-throttling-pool\/","name":"Throttling pool"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Bartłomiej Święcki"},"headline":"Throttling Pool","description":"In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.\nObject pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves.","inLanguage":"en","wordCount":1152,"datePublished":"2022-11-22T00:00:00","dateModified":"2022-11-22T00:00:00","image":"https:\/\/blog.bswiecki.dev\/","keywords":["go, howto, code"],"mainEntityOfPage":"https:\/\/blog.bswiecki.dev\/post\/2022-11-22-throttling-pool\/","publisher":{"@type":"Organization","name":"https:\/\/blog.bswiecki.dev\/","logo":{"@type":"ImageObject","url":"https:\/\/blog.bswiecki.dev\/","height":60,"width":60}}}</script><meta property="og:title" content="Throttling Pool"><meta property="og:description" content="In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves."><meta property="og:url" content="https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/"><meta property="og:type" content="website"><meta property="og:site_name" content="Just a dev blog"><meta name=twitter:title content="Throttling Pool"><meta name=twitter:description content="In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.106.0"><link rel=alternate href=https://blog.bswiecki.dev/index.xml type=application/rss+xml title="Just a dev blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://blog.bswiecki.dev/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://blog.bswiecki.dev/css/syntax.css><link rel=stylesheet href=https://blog.bswiecki.dev/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://blog.bswiecki.dev/>Just a dev blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=https://blog.bswiecki.dev/>Blog</a></li><li><a title=About href=https://blog.bswiecki.dev/page/about/>About</a></li><li><a title=Tags href=https://blog.bswiecki.dev/tags>Tags</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Throttling Pool</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on November 22, 2022
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Bartłomiej Święcki</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>In my <a href=https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/>last post</a> I presented few techniques useful for limiting simultaneous operations in Go.
Such throttlers are indeed a very neat tools to keep our resources under control.
However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.</p><h2 id=object-pools-in-go>Object pools in go</h2><p>Even though golang has a very efficient memory management system, there are some cases where
we would like to manage the memory by ourselves. There may be many reasons for that. One may want to
ensure that the amount of allocated memory does not cross some predefined limit. It may also
be the case that frequent allocations and deallocations of memory start causing issues due to
a huge CPU cost. Those factors are especially important in more complex systems with tight
memory budget such as databases. And it turns out that I had a chance to work with one such database
called <a href=https://immudb.io/>immudb</a> for more than a year now.</p><p>In <code>immudb</code> there are some <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/tx.go#L29>larger scratchpad objects</a> used during the transaction commit that are
<a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L366>preallocated</a> when the database is loaded. Once a writer starts preparing a transaction,
such <em>scratchpad</em> object is <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L1217>taken from the pool</a> to be <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L1221>returned back to it</a>
once the commit finishes.</p><p>Sounds familiar? Looks almost identical to the technique used for throttling the number
of simultaneous operations with tokens that I presented in the <a href=https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/>previous post</a>.
But instead of fetching a token from the pool that is of no use, we can fetch a useful object.
This mechanism is used by <code>immudb</code> to keep the number of simultaneous
transactions <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/immustore.go#L1047>under control</a>. Without such limit, it would be easy to <em>force</em> the database
to use huge amount of resources (which some may refer to as a <a href=https://en.wikipedia.org/wiki/Denial-of-service_attack>DoS</a> attack if for example
the database runs out of memory).</p><p>The implementation in immudb is <a href=https://github.com/codenotary/immudb/blob/v1.4.0/embedded/store/txpool.go#L39>based on a mutex</a> whereas in this blog post I&rsquo;ll focus on
a channel-based implementation that will be similar to what we&rsquo;ve seen with token-based throttlers.</p><h2 id=pool-throttler>Pool-throttler</h2><p>Let&rsquo;s do some exercise now and create such a throttling pool.</p><p>I decided to use <a href=https://go.dev/doc/tutorial/generics>generics</a> in the implementation.
Instead of creating a pool that works on the <code>interface{}</code> type (or some other concrete one)
we can leave the selection of that underlying type to the user of the pool.
That way we can avoid a lot of conversions and type assertions ruling out unnecessary casting cost.</p><p>As with tokens, the core of pool-based throttler will again be a channel:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolLimiter</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=kd>chan</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In case of token-based throttlers the initialization of such channel was simple
because the token type was empty and did not contain any information.
In case of a pool, objects in the pool must be initialized correctly.
For that reason I decided to add a dedicated initialization functor when creating
objects in the pool:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>NewPoolLimiter</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>](</span><span class=nx>poolSize</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>gen</span> <span class=kd>func</span><span class=p>()</span> <span class=nx>T</span><span class=p>)</span> <span class=nx>PoolLimiter</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>ret</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>poolLimiter</span><span class=p>[</span><span class=nx>T</span><span class=p>]{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ch</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>poolSize</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Preallocate the pool of objects
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>poolSize</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ret</span><span class=p>.</span><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nf>gen</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>ret</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And now the essence of the pool - acquiring and releasing resources.
Let&rsquo;s write few implementations for different use cases, starting with the simplest one.</p><h2 id=blocking-acquire>Blocking acquire</h2><p>The easiest acquire method to write is the blocking one that will wait until there
is at least one object in the pool:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>poolLimiter</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Acquire</span><span class=p>()</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&lt;-</span><span class=nx>p</span><span class=p>.</span><span class=nx>ch</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Nothing really fancy here - the channel gives us exactly the functionality that we need.
But you may also have noticed that contrary to <a href=https://github.com/byo/go-limiters/blob/v0.1.0/interfaces.go#L15>the previous token-based implementations</a>
I decided not to return the release function from that method.</p><p>Instead there will be a dedicated <code>Release</code> function in the pool itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>poolLimiter</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Release</span><span class=p>(</span><span class=nx>item</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span><span class=p>.</span><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>item</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Why such change of the interface? I did some benchmarks and this way the implementation
is almost twice as fast (41 ns/op vs 72 ns/op). The overhead of additional function value is
pretty significant here. For that reason I also changed the interface of the original
token-based throttler (that code even simplified which is usually a good sign).</p><p>As a side note, the code written so far looks too trivial, isn&rsquo;t it?
Well, it just proves that golang&rsquo;s built-in primitives are really well designed.</p><h2 id=non-blocking-acquire>Non-blocking acquire</h2><p>Let&rsquo;s move to something a bit more complex now - acquire that will return an error if the pool is empty:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>poolLimiter</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>AcquireNoWait</span><span class=p>()</span> <span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>item</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>item</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nx>p</span><span class=p>.</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>item</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>item</span><span class=p>,</span> <span class=nx>ErrResourceExhausted</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Nothing really fancy here - the built-in <a href=https://go.dev/tour/concurrency/5>select</a> is all we need.</p><p>The returned item is created and initialized at the beginning of this method
which may be a bit surprising. This is needed if the pool is empty. In such
case we still have to return some instance of the <code>T</code> type along with an error.
Creating a default value initialized at the beginning does the trick.</p><h2 id=context-aware-acquire>Context-aware acquire</h2><p>The most complex (but still fitting in just a few lines of code) is the context-aware
acquire:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>poolLimiter</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>AcquireCtx</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>T</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>item</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>item</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nx>p</span><span class=p>.</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>item</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>item</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The code is almost identical to the non-blocking acquire. If the pool is empty
and we have to wait for some freed up resources, catching context cancellation
with the <a href=https://go.dev/tour/concurrency/5>select</a> built-in allows the function to give up and return an error.
Additional <code>if ctx.Err() == nil</code> ensures that we won&rsquo;t even try to fetch
the resource if the context has already been cancelled.</p><h2 id=exercise---token-from-pool>Exercise - token from pool</h2><p>We can try to compare the newly written pool against the older token limiter.
For that reason I&rsquo;ve created a simple wrapper <code>struct</code> encapsulating the pool
but exposing the token limiter interface instead:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>poolLimiterToTokenLimiter</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span> <span class=nx>PoolLimiter</span><span class=p>[</span><span class=kd>struct</span><span class=p>{}]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewTokenLimiterFromPoolLimiter</span><span class=p>(</span><span class=nx>maxTokens</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>CancellableTokenLimiter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>poolLimiterToTokenLimiter</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>l</span><span class=p>:</span> <span class=nf>NewPoolLimiter</span><span class=p>(</span><span class=nx>maxTokens</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=kd>struct</span><span class=p>{}</span> <span class=p>{</span> <span class=k>return</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>poolLimiterToTokenLimiter</span><span class=p>)</span> <span class=nf>Acquire</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>.</span><span class=nx>l</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>poolLimiterToTokenLimiter</span><span class=p>)</span> <span class=nf>AcquireNoWait</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>l</span><span class=p>.</span><span class=nf>AcquireNoWait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>poolLimiterToTokenLimiter</span><span class=p>)</span> <span class=nf>AcquireCtx</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>l</span><span class=p>.</span><span class=nf>AcquireCtx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>poolLimiterToTokenLimiter</span><span class=p>)</span> <span class=nf>Release</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>.</span><span class=nx>l</span><span class=p>.</span><span class=nf>Release</span><span class=p>(</span><span class=kd>struct</span><span class=p>{}{})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Such implementation was roughly 30% slower than the dedicated token limiter implementation (48.54 ns/op vs 36.90 ns/op).
My guess is that this is mostly caused by indirect calls and additional returned value. I think that the gap will become smaller
in future versions of the go compiler that will be able to inline functions and detect dead code much better.</p><h2 id=next>Next</h2><p>The topic of throttling is still not fully explored here so stay tuned for more updates.</p><p>And as before, you can find the full source code with all test and benchmarks in <a href=https://github.com/byo/go-limiters/tree/v0.2.0>Github repository</a>.</p><div class=blog-tags><a href=https://blog.bswiecki.dev//tags/go/>go</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/howto/>howto</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/code/>code</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/ data-toggle=tooltip data-placement=top title="Throttling in Go">&larr; Previous Post</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blogbswieckidev.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/byo title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/bswiecki title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://keybase.io/byo title=Keybase><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-keybase fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Bartłomiej Święcki
&nbsp;&bull;&nbsp;&copy;
2022
&nbsp;&bull;&nbsp;
<a href=https://blog.bswiecki.dev/>Just a dev blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.106.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script>
<script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=https://blog.bswiecki.dev/js/main.js></script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://blog.bswiecki.dev/js/load-photoswipe.js></script></body></html>