<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Throttling in Go - Just a dev blog</title><meta name=description content="Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server."><meta name=author content="Bartłomiej Święcki"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Just a dev blog","url":"https:\/\/blog.bswiecki.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/blog.bswiecki.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/blog.bswiecki.dev\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/blog.bswiecki.dev\/post\/2022-10-07-throttling-in-go\/","name":"Throttling in go"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Bartłomiej Święcki"},"headline":"Throttling in Go","description":"Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don\u0026rsquo;t have to deal with memory management, it has lightweight goroutines and we don\u0026rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server.","inLanguage":"en","wordCount":1397,"datePublished":"2022-10-07T00:00:00","dateModified":"2022-10-07T00:00:00","image":"https:\/\/blog.bswiecki.dev\/","keywords":["go, howto, code"],"mainEntityOfPage":"https:\/\/blog.bswiecki.dev\/post\/2022-10-07-throttling-in-go\/","publisher":{"@type":"Organization","name":"https:\/\/blog.bswiecki.dev\/","logo":{"@type":"ImageObject","url":"https:\/\/blog.bswiecki.dev\/","height":60,"width":60}}}</script><meta property="og:title" content="Throttling in Go"><meta property="og:description" content="Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server."><meta property="og:url" content="https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/"><meta property="og:type" content="website"><meta property="og:site_name" content="Just a dev blog"><meta name=twitter:title content="Throttling in Go"><meta name=twitter:description content="Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.106.0"><link rel=alternate href=https://blog.bswiecki.dev/index.xml type=application/rss+xml title="Just a dev blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://blog.bswiecki.dev/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://blog.bswiecki.dev/css/syntax.css><link rel=stylesheet href=https://blog.bswiecki.dev/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://blog.bswiecki.dev/>Just a dev blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=https://blog.bswiecki.dev/>Blog</a></li><li><a title=About href=https://blog.bswiecki.dev/page/about/>About</a></li><li><a title=Tags href=https://blog.bswiecki.dev/tags>Tags</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Throttling in Go</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on October 7, 2022
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Bartłomiej Święcki</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>Go language makes a good job at making hard things simple. It compiles the code so that it runs fast,
it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight
goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those
language constructs combined with sane defaults will be good enough. Just like writing a web server.
Its almost never the case that we have to think about how many parallel requests we can handle.</p><p>But sometimes we need to have more control over our resources.</p><h2 id=exploring-restic>Exploring <a href=https://restic.net/>Restic</a></h2><p>Few years ago, while I was still a newbie in the go world, I was exploring internals of <a href=https://restic.net/>Restic</a> -
a nice backup tool written in go. While doing so I learned a lot, but one thing caught my attention.
There was an upper limit of simultaneous upload to a remote storage such as an s3 server.</p><p>When I first saw <a href=https://restic.net/>Restic</a> in action I thought that this must have been done using some upload queue,
maybe some upload scheduler or some other complicated machinery. But the implementation in <a href=https://restic.net/>Restic</a>
turned out to be much simpler. Each upload is realized in a separate goroutine and there are many of
them spawned in parallel, much more than what is really necessary to saturate upload speed. But to avoid
unbounded number of parallel uploads, there&rsquo;s a throttling mechanism based on upload <em>tokens</em>. Those <em>tokens</em>
are <a href=https://github.com/restic/restic/blob/v0.5.0/src/restic/backend/s3/s3.go#L146>acquired</a> before sending data to the remote storage and <a href=https://github.com/restic/restic/blob/v0.5.0/src/restic/backend/s3/s3.go#L184>released</a>
once the upload is done. The number of upload <em>tokens</em> is limited constraining the number of parallel uploads.</p><p>Since I was a golang newbie back then, I didn&rsquo;t really understand the code when I first looked at it.
It was using channels so I thought that it is related to some communication between goroutines.
I only realized that this is a very neat throttling mechanism a bit later.</p><h2 id=channels-as-token-machines>Channels as token machines</h2><p>How is it done? A dedicated go channel is used as a token disposal machine. To do some throttled operation,
one takes the token from that channel (<code>token := &lt;- channel</code>) and gives it back once the operation is finished
(<code>channel &lt;- token</code>). If there are no tokens left, the channel will naturally block the goroutine until someone
else returns previously acquired token back to the pool.</p><p>All of that can be done in just few lines of go code.</p><p>In this post I&rsquo;d like to play a bit with this idea and show you how easy such throttlers can be implemented.</p><h2 id=the-basic-implementation>The basic implementation</h2><p>Let&rsquo;s start with some worker code. As we&rsquo;ve discussed before the worker should first acquire the token
and give it back to the pool once the task is finished:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>token</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>tokens</span>                  <span class=c1>// Grab the token, can block
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>tokens</span> <span class=o>&lt;-</span> <span class=nx>token</span> <span class=p>}()</span>  <span class=c1>// Return the token
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// do the hard work...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Before we can use the <code>tokens</code> channel it must be initialized by filling it up with tokens:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>tokensCount</span> <span class=p>=</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tokens</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=nx>tokensCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>initTokens</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>tokensCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>tokens</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can also extract the throttler to a separate easy to use object:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Throttler</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewThrottler</span><span class=p>(</span><span class=nx>max</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Throttler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=nx>max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>max</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>Throttler</span><span class=p>{</span><span class=nx>ch</span><span class=p>:</span> <span class=nx>ch</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Throttler</span><span class=p>)</span> <span class=nf>Acquire</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>token</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>.</span><span class=nx>ch</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>token</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and use it in our worker:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>tokensCount</span> <span class=p>=</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tokens</span> <span class=p>=</span> <span class=nf>NewThrottler</span><span class=p>(</span><span class=nx>tokensCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>tokens</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>()()</span>    <span class=c1>// Throttle
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// do the hard work...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>You may notice that the <code>Acquire</code> method returns a <code>func()</code> object instead of the token.
That function will release the token back to the pool when executed.
That way the acquire and the release of the token are tightly coupled together
and we can both acquired the token and schedule its release upon
function exit in a nice one-liner.</p><h2 id=reversed-implementation>Reversed implementation</h2><p>The implementation above can be interpreted as the channel being a set of idle tokens.
Worker takes the token from that set and gives it back once done with the job.</p><p>But we can also reverse the idea and use channel as a holder of tokens for busy workers.
Before doing the task, worker puts its token into the channel and takes it back
once the work is finished. Since the channel has the maximum capacity, once it is full,
more <em>busy</em> tokens will have to wait until someone takes one&rsquo;s token from the channel:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Throttler</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewThrottler</span><span class=p>(</span><span class=nx>max</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Throttler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=nx>max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>Throttler</span><span class=p>{</span><span class=nx>ch</span><span class=p>:</span> <span class=nx>ch</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Throttler</span><span class=p>)</span> <span class=nf>Acquire</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>.</span><span class=nx>ch</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The biggest difference here is that the channel doesn&rsquo;t have to be populated with tokens
during initialization but otherwise there&rsquo;s not much of a difference between those two implementations.</p><h2 id=old-style-implementation>Old-style implementation</h2><p>In previous examples the core of the throttler was a go channel. But the same can be implemented
using old-style synchronization primitives:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Throttler</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>cnt</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span>   <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span>   <span class=nx>sync</span><span class=p>.</span><span class=nx>Cond</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewThrottler</span><span class=p>(</span><span class=nx>max</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Throttler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ret</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Throttler</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cnt</span><span class=p>:</span> <span class=nx>max</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>ret</span><span class=p>.</span><span class=nx>c</span><span class=p>.</span><span class=nx>L</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>ret</span><span class=p>.</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>ret</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Throttler</span><span class=p>)</span> <span class=nf>Acquire</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>c</span><span class=p>.</span><span class=nx>cnt</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>c</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>cnt</span><span class=o>--</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>cnt</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span><span class=p>.</span><span class=nx>c</span><span class=p>.</span><span class=nf>Signal</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Much more complex implementation compared to the previous one, right?</p><p>When I first wrote it I assumed that there will be a huge performance boost because we replaced a <em>heavy</em>
channel object with a <em>lightweight</em> low-level synchronization mechanisms.</p><p>But after I run some benchmarks it turned out that this implementation is only between
12% to 19% faster than our original one. This does not sound like a huge difference to me.
Maybe in some very specific CPU-sensitive use cases it could be beneficial but I believe that
if each spent CPU cycle is making the difference then languages such as c or c++ (or even assembly)
would be a better fit there.</p><p>Putting performance difference aside, there&rsquo;s one more huge difference I&rsquo;d like to point out.</p><h2 id=cancellable-waits>Cancellable waits</h2><p>Our channel-based throttlers have one huge advantage over the one based on mutex.
They can easily be extended to also support cancellation through context.</p><p>Here&rsquo;s an example of a cancellable <code>Acquire</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Throttler</span><span class=p>)</span> <span class=nf>Acquire</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=kd>func</span><span class=p>(),</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>.</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>c</span><span class=p>.</span><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If the context is cancelled for any reason, the token acquire will now simply return an error:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>releaseToken</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tokens</span><span class=p>.</span><span class=nf>AcquireCtx</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>releaseToken</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// do the hard work...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Why we would need such context-aware throttler? Let&rsquo;s take a simple http server as an example.
A http request can be cancelled at any time as a result of the client dropping the connection
or server shutdown. Waiting for the token in case the request is already cancelled
is most likely pointless and the request handler should return immediately.</p><h2 id=low-level-does-not-always-mean-more-powerful>Low-level does not always mean more powerful</h2><p>Such cancellable acquire can not be easily implemented with low-level mutexes and condition variables.
Locking a mutex or waiting on a condition in go can not be interrupted. This means that the channel-based
version is not only easier to write and understand but also handles much broader set of use-cases.</p><p>We could of course try experimenting with some complex implementation of a mutex-based throttler supporting cancellation.
But at this point I don&rsquo;t believe that we would gain much more with it.
Considering relatively small performance gains I&rsquo;d rather stay with the channel-based implementation.</p><h2 id=future-improvements>Future improvements</h2><p>I hope you liked my introduction to throttling in go. Of course I only scratched the surface of this topic
so stay tuned for future posts where I&rsquo;ll show few more tips and tricks.</p><h2 id=see-you-on-githubgo_limiters>See you on <a href=https://github.com/byo/go-limiters/tree/v0.1.0>GitHub</a></h2><p>I&rsquo;ve gathered various implementations of throttlers in <a href=https://github.com/byo/go-limiters/tree/v0.1.0>this github repository</a>. It&rsquo;s a well
tested (aiming at 100% test coverage) tiny go module that anybody can use. It also contains benchmarks
to check the performance difference between various implementations.</p><div class=blog-tags><a href=https://blog.bswiecki.dev//tags/go/>go</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/howto/>howto</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/code/>code</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/ data-toggle=tooltip data-placement=top title="Multi-CPU Github Actions with Go">&larr; Previous Post</a></li><li class=next><a href=https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/ data-toggle=tooltip data-placement=top title="Throttling Pool">Next Post &rarr;</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blogbswieckidev.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/byo title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/bswiecki title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://keybase.io/byo title=Keybase><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-keybase fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Bartłomiej Święcki
&nbsp;&bull;&nbsp;&copy;
2022
&nbsp;&bull;&nbsp;
<a href=https://blog.bswiecki.dev/>Just a dev blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.106.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script>
<script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=https://blog.bswiecki.dev/js/main.js></script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://blog.bswiecki.dev/js/load-photoswipe.js></script></body></html>