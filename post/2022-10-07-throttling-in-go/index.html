<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Throttling in Go | Just a dev blog</title><meta name=keywords content="go,howto,code"><meta name=description content="Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server."><meta name=author content><link rel=canonical href=https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/><link crossorigin=anonymous href=https://blog.bswiecki.dev/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://blog.bswiecki.dev/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.bswiecki.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.bswiecki.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.bswiecki.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.bswiecki.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.bswiecki.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Throttling in Go"><meta property="og:description" content="Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-07T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-07T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Throttling in Go"><meta name=twitter:description content="Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bswiecki.dev/post/"},{"@type":"ListItem","position":2,"name":"Throttling in Go","item":"https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Throttling in Go","name":"Throttling in Go","description":"Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don\u0026rsquo;t have to deal with memory management, it has lightweight goroutines and we don\u0026rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server.","keywords":["go","howto","code"],"articleBody":"Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don’t have to deal with memory management, it has lightweight goroutines and we don’t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server. Its almost never the case that we have to think about how many parallel requests we can handle.\nBut sometimes we need to have more control over our resources.\nExploring Restic Few years ago, while I was still a newbie in the go world, I was exploring internals of Restic - a nice backup tool written in go. While doing so I learned a lot, but one thing caught my attention. There was an upper limit of simultaneous upload to a remote storage such as an s3 server.\nWhen I first saw Restic in action I thought that this must have been done using some upload queue, maybe some upload scheduler or some other complicated machinery. But the implementation in Restic turned out to be much simpler. Each upload is realized in a separate goroutine and there are many of them spawned in parallel, much more than what is really necessary to saturate upload speed. But to avoid unbounded number of parallel uploads, there’s a throttling mechanism based on upload tokens. Those tokens are acquired before sending data to the remote storage and released once the upload is done. The number of upload tokens is limited constraining the number of parallel uploads.\nSince I was a golang newbie back then, I didn’t really understand the code when I first looked at it. It was using channels so I thought that it is related to some communication between goroutines. I only realized that this is a very neat throttling mechanism a bit later.\nChannels as token machines How is it done? A dedicated go channel is used as a token disposal machine. To do some throttled operation, one takes the token from that channel (token := \u003c- channel) and gives it back once the operation is finished (channel \u003c- token). If there are no tokens left, the channel will naturally block the goroutine until someone else returns previously acquired token back to the pool.\nAll of that can be done in just few lines of go code.\nIn this post I’d like to play a bit with this idea and show you how easy such throttlers can be implemented.\nThe basic implementation Let’s start with some worker code. As we’ve discussed before the worker should first acquire the token and give it back to the pool once the task is finished:\nfunc worker() { token := \u003c- tokens // Grab the token, can block defer func() { tokens \u003c- token }() // Return the token // do the hard work... } Before we can use the tokens channel it must be initialized by filling it up with tokens:\nconst tokensCount = 30 var tokens = make(chan struct{}, tokensCount) func initTokens() { for i:=0; i\u003ctokensCount; i++ { tokens \u003c- struct{}{} } } We can also extract the throttler to a separate easy to use object:\ntype Throttler struct { ch chan struct{} } func NewThrottler(max int) *Throttler { ch := make(chan struct{}, max) for i := 0; i \u003c max; i++ { ch \u003c- struct{}{} } return \u0026Throttler{ch: ch} } func (c *Throttler) Acquire() func() { token := \u003c-c.ch return func() { c.ch \u003c- token } } and use it in our worker:\nconst tokensCount = 30 var tokens = NewThrottler(tokensCount) func worker() { defer tokens.Acquire()() // Throttle // do the hard work... } You may notice that the Acquire method returns a func() object instead of the token. That function will release the token back to the pool when executed. That way the acquire and the release of the token are tightly coupled together and we can both acquired the token and schedule its release upon function exit in a nice one-liner.\nReversed implementation The implementation above can be interpreted as the channel being a set of idle tokens. Worker takes the token from that set and gives it back once done with the job.\nBut we can also reverse the idea and use channel as a holder of tokens for busy workers. Before doing the task, worker puts its token into the channel and takes it back once the work is finished. Since the channel has the maximum capacity, once it is full, more busy tokens will have to wait until someone takes one’s token from the channel:\ntype Throttler struct { ch chan struct{} } func NewThrottler(max int) *Throttler { ch := make(chan struct{}, max) return \u0026Throttler{ch: ch} } func (c *Throttler) Acquire() func() { c.ch \u003c- struct{}{} return func() { \u003c-c.ch } } The biggest difference here is that the channel doesn’t have to be populated with tokens during initialization but otherwise there’s not much of a difference between those two implementations.\nOld-style implementation In previous examples the core of the throttler was a go channel. But the same can be implemented using old-style synchronization primitives:\ntype Throttler struct { cnt int m sync.Mutex c sync.Cond } func NewThrottler(max int) *Throttler { ret := \u0026Throttler{ cnt: max, } ret.c.L = \u0026ret.m return ret } func (c *Throttler) Acquire() func() { c.m.Lock() defer c.m.Unlock() for c.cnt \u003c= 0 { c.c.Wait() } c.cnt-- return func() { c.m.Lock() defer c.m.Unlock() c.cnt++ c.c.Signal() } } Much more complex implementation compared to the previous one, right?\nWhen I first wrote it I assumed that there will be a huge performance boost because we replaced a heavy channel object with a lightweight low-level synchronization mechanisms.\nBut after I run some benchmarks it turned out that this implementation is only between 12% to 19% faster than our original one. This does not sound like a huge difference to me. Maybe in some very specific CPU-sensitive use cases it could be beneficial but I believe that if each spent CPU cycle is making the difference then languages such as c or c++ (or even assembly) would be a better fit there.\nPutting performance difference aside, there’s one more huge difference I’d like to point out.\nCancellable waits Our channel-based throttlers have one huge advantage over the one based on mutex. They can easily be extended to also support cancellation through context.\nHere’s an example of a cancellable Acquire:\nfunc (c *Throttler) Acquire(ctx context.Context) (func(), error) { if ctx.Err() == nil { select { case \u003c-c.ch: return func() { c.ch \u003c- struct{}{} }, nil case \u003c-ctx.Done(): break } } return nil, ctx.Err() } If the context is cancelled for any reason, the token acquire will now simply return an error:\nfunc worker(ctx context.Context) error { releaseToken, err := tokens.AcquireCtx(ctx) if err != nil { return err } defer releaseToken() // do the hard work... } Why we would need such context-aware throttler? Let’s take a simple http server as an example. A http request can be cancelled at any time as a result of the client dropping the connection or server shutdown. Waiting for the token in case the request is already cancelled is most likely pointless and the request handler should return immediately.\nLow-level does not always mean more powerful Such cancellable acquire can not be easily implemented with low-level mutexes and condition variables. Locking a mutex or waiting on a condition in go can not be interrupted. This means that the channel-based version is not only easier to write and understand but also handles much broader set of use-cases.\nWe could of course try experimenting with some complex implementation of a mutex-based throttler supporting cancellation. But at this point I don’t believe that we would gain much more with it. Considering relatively small performance gains I’d rather stay with the channel-based implementation.\nFuture improvements I hope you liked my introduction to throttling in go. Of course I only scratched the surface of this topic so stay tuned for future posts where I’ll show few more tips and tricks.\nSee you on GitHub I’ve gathered various implementations of throttlers in this github repository. It’s a well tested (aiming at 100% test coverage) tiny go module that anybody can use. It also contains benchmarks to check the performance difference between various implementations.\n","wordCount":"1397","inLanguage":"en","datePublished":"2022-10-07T00:00:00Z","dateModified":"2022-10-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/"},"publisher":{"@type":"Organization","name":"Just a dev blog","logo":{"@type":"ImageObject","url":"https://blog.bswiecki.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bswiecki.dev/ accesskey=h title="Just a dev blog (Alt + H)">Just a dev blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.bswiecki.dev/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.bswiecki.dev/page/about/ title=About><span>About</span></a></li><li><a href=https://blog.bswiecki.dev/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Throttling in Go</h1><div class=post-meta><span title='2022-10-07 00:00:00 +0000 UTC'>October 7, 2022</span></div></header><div class=post-content><p>Go language makes a good job at making hard things simple. It compiles the code so that it runs fast,
it comes with garbage collector so we don&rsquo;t have to deal with memory management, it has lightweight
goroutines and we don&rsquo;t have to think a lot about concurrency limits. And in majority of cases all those
language constructs combined with sane defaults will be good enough. Just like writing a web server.
Its almost never the case that we have to think about how many parallel requests we can handle.</p><p>But sometimes we need to have more control over our resources.</p><h2 id=exploring-restic>Exploring <a href=https://restic.net/>Restic</a><a hidden class=anchor aria-hidden=true href=#exploring-restic>#</a></h2><p>Few years ago, while I was still a newbie in the go world, I was exploring internals of <a href=https://restic.net/>Restic</a> -
a nice backup tool written in go. While doing so I learned a lot, but one thing caught my attention.
There was an upper limit of simultaneous upload to a remote storage such as an s3 server.</p><p>When I first saw <a href=https://restic.net/>Restic</a> in action I thought that this must have been done using some upload queue,
maybe some upload scheduler or some other complicated machinery. But the implementation in <a href=https://restic.net/>Restic</a>
turned out to be much simpler. Each upload is realized in a separate goroutine and there are many of
them spawned in parallel, much more than what is really necessary to saturate upload speed. But to avoid
unbounded number of parallel uploads, there&rsquo;s a throttling mechanism based on upload <em>tokens</em>. Those <em>tokens</em>
are <a href=https://github.com/restic/restic/blob/v0.5.0/src/restic/backend/s3/s3.go#L146>acquired</a> before sending data to the remote storage and <a href=https://github.com/restic/restic/blob/v0.5.0/src/restic/backend/s3/s3.go#L184>released</a>
once the upload is done. The number of upload <em>tokens</em> is limited constraining the number of parallel uploads.</p><p>Since I was a golang newbie back then, I didn&rsquo;t really understand the code when I first looked at it.
It was using channels so I thought that it is related to some communication between goroutines.
I only realized that this is a very neat throttling mechanism a bit later.</p><h2 id=channels-as-token-machines>Channels as token machines<a hidden class=anchor aria-hidden=true href=#channels-as-token-machines>#</a></h2><p>How is it done? A dedicated go channel is used as a token disposal machine. To do some throttled operation,
one takes the token from that channel (<code>token := &lt;- channel</code>) and gives it back once the operation is finished
(<code>channel &lt;- token</code>). If there are no tokens left, the channel will naturally block the goroutine until someone
else returns previously acquired token back to the pool.</p><p>All of that can be done in just few lines of go code.</p><p>In this post I&rsquo;d like to play a bit with this idea and show you how easy such throttlers can be implemented.</p><h2 id=the-basic-implementation>The basic implementation<a hidden class=anchor aria-hidden=true href=#the-basic-implementation>#</a></h2><p>Let&rsquo;s start with some worker code. As we&rsquo;ve discussed before the worker should first acquire the token
and give it back to the pool once the task is finished:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>token</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>tokens</span>                  <span style=color:#75715e>// Grab the token, can block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>tokens</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>token</span> }()  <span style=color:#75715e>// Return the token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do the hard work...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Before we can use the <code>tokens</code> channel it must be initialized by filling it up with tokens:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokensCount</span> = <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tokens</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#a6e22e>tokensCount</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>initTokens</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span><span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span>&lt;<span style=color:#a6e22e>tokensCount</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can also extract the throttler to a separate easy to use object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Throttler</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewThrottler</span>(<span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#a6e22e>max</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>max</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Throttler</span>{<span style=color:#a6e22e>ch</span>: <span style=color:#a6e22e>ch</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span>) <span style=color:#a6e22e>Acquire</span>() <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>token</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ch</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>token</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and use it in our worker:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokensCount</span> = <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tokens</span> = <span style=color:#a6e22e>NewThrottler</span>(<span style=color:#a6e22e>tokensCount</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>Acquire</span>()()    <span style=color:#75715e>// Throttle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do the hard work...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>You may notice that the <code>Acquire</code> method returns a <code>func()</code> object instead of the token.
That function will release the token back to the pool when executed.
That way the acquire and the release of the token are tightly coupled together
and we can both acquired the token and schedule its release upon
function exit in a nice one-liner.</p><h2 id=reversed-implementation>Reversed implementation<a hidden class=anchor aria-hidden=true href=#reversed-implementation>#</a></h2><p>The implementation above can be interpreted as the channel being a set of idle tokens.
Worker takes the token from that set and gives it back once done with the job.</p><p>But we can also reverse the idea and use channel as a holder of tokens for busy workers.
Before doing the task, worker puts its token into the channel and takes it back
once the work is finished. Since the channel has the maximum capacity, once it is full,
more <em>busy</em> tokens will have to wait until someone takes one&rsquo;s token from the channel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Throttler</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewThrottler</span>(<span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#a6e22e>max</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Throttler</span>{<span style=color:#a6e22e>ch</span>: <span style=color:#a6e22e>ch</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span>) <span style=color:#a6e22e>Acquire</span>() <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() { <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ch</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The biggest difference here is that the channel doesn&rsquo;t have to be populated with tokens
during initialization but otherwise there&rsquo;s not much of a difference between those two implementations.</p><h2 id=old-style-implementation>Old-style implementation<a hidden class=anchor aria-hidden=true href=#old-style-implementation>#</a></h2><p>In previous examples the core of the throttler was a go channel. But the same can be implemented
using old-style synchronization primitives:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Throttler</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cnt</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>m</span>   <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>   <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Cond</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewThrottler</span>(<span style=color:#a6e22e>max</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Throttler</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cnt</span>: <span style=color:#a6e22e>max</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span>.<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ret</span>.<span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span>) <span style=color:#a6e22e>Acquire</span>() <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cnt</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cnt</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cnt</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Signal</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Much more complex implementation compared to the previous one, right?</p><p>When I first wrote it I assumed that there will be a huge performance boost because we replaced a <em>heavy</em>
channel object with a <em>lightweight</em> low-level synchronization mechanisms.</p><p>But after I run some benchmarks it turned out that this implementation is only between
12% to 19% faster than our original one. This does not sound like a huge difference to me.
Maybe in some very specific CPU-sensitive use cases it could be beneficial but I believe that
if each spent CPU cycle is making the difference then languages such as c or c++ (or even assembly)
would be a better fit there.</p><p>Putting performance difference aside, there&rsquo;s one more huge difference I&rsquo;d like to point out.</p><h2 id=cancellable-waits>Cancellable waits<a hidden class=anchor aria-hidden=true href=#cancellable-waits>#</a></h2><p>Our channel-based throttlers have one huge advantage over the one based on mutex.
They can easily be extended to also support cancellation through context.</p><p>Here&rsquo;s an example of a cancellable <code>Acquire</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Throttler</span>) <span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#66d9ef>func</span>(), <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ch</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{} }, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If the context is cancelled for any reason, the token acquire will now simply return an error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>releaseToken</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>AcquireCtx</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>releaseToken</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do the hard work...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Why we would need such context-aware throttler? Let&rsquo;s take a simple http server as an example.
A http request can be cancelled at any time as a result of the client dropping the connection
or server shutdown. Waiting for the token in case the request is already cancelled
is most likely pointless and the request handler should return immediately.</p><h2 id=low-level-does-not-always-mean-more-powerful>Low-level does not always mean more powerful<a hidden class=anchor aria-hidden=true href=#low-level-does-not-always-mean-more-powerful>#</a></h2><p>Such cancellable acquire can not be easily implemented with low-level mutexes and condition variables.
Locking a mutex or waiting on a condition in go can not be interrupted. This means that the channel-based
version is not only easier to write and understand but also handles much broader set of use-cases.</p><p>We could of course try experimenting with some complex implementation of a mutex-based throttler supporting cancellation.
But at this point I don&rsquo;t believe that we would gain much more with it.
Considering relatively small performance gains I&rsquo;d rather stay with the channel-based implementation.</p><h2 id=future-improvements>Future improvements<a hidden class=anchor aria-hidden=true href=#future-improvements>#</a></h2><p>I hope you liked my introduction to throttling in go. Of course I only scratched the surface of this topic
so stay tuned for future posts where I&rsquo;ll show few more tips and tricks.</p><h2 id=see-you-on-githubgo_limiters>See you on <a href=https://github.com/byo/go-limiters/tree/v0.1.0>GitHub</a><a hidden class=anchor aria-hidden=true href=#see-you-on-githubgo_limiters>#</a></h2><p>I&rsquo;ve gathered various implementations of throttlers in <a href=https://github.com/byo/go-limiters/tree/v0.1.0>this github repository</a>. It&rsquo;s a well
tested (aiming at 100% test coverage) tiny go module that anybody can use. It also contains benchmarks
to check the performance difference between various implementations.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bswiecki.dev/tags/go/>go</a></li><li><a href=https://blog.bswiecki.dev/tags/howto/>howto</a></li><li><a href=https://blog.bswiecki.dev/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.bswiecki.dev/>Just a dev blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><link href=https://blog.bswiecki.dev/css/mermaid.css type=text/css rel=stylesheet><script defer src=https://blog.bswiecki.dev/js/mermaid.js onload=mermaid.initialize({startOnLoad:!0})></script>
<link href=https://blog.bswiecki.dev/css/katex.css type=text/css rel=stylesheet><script defer src=https://blog.bswiecki.dev/js/katex.js></script>
<script defer src=https://blog.bswiecki.dev/js/katex-auto-render.js onload=renderMathInElement(document.body)></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>