<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Multi-CPU Github Actions with Go - Just a dev blog</title><meta name=description content="When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops)."><meta name=author content="Bartłomiej Święcki"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Just a dev blog","url":"https:\/\/blog.bswiecki.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/blog.bswiecki.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/blog.bswiecki.dev\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/blog.bswiecki.dev\/post\/2022-07-19-multi-cpu-github-actions-with-go\/","name":"Multi CPU github actions with go"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Bartłomiej Święcki"},"headline":"Multi-CPU Github Actions with Go","description":"When we think about CPU architecture usually there\u0026rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.\nBut there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops).","inLanguage":"en","wordCount":1050,"datePublished":"2022-07-19T00:00:00","dateModified":"2022-07-19T00:00:00","image":"https:\/\/blog.bswiecki.dev\/","keywords":["go, howto, github, til, ops, qemu"],"mainEntityOfPage":"https:\/\/blog.bswiecki.dev\/post\/2022-07-19-multi-cpu-github-actions-with-go\/","publisher":{"@type":"Organization","name":"https:\/\/blog.bswiecki.dev\/","logo":{"@type":"ImageObject","url":"https:\/\/blog.bswiecki.dev\/","height":60,"width":60}}}</script><meta property="og:title" content="Multi-CPU Github Actions with Go"><meta property="og:description" content="When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops)."><meta property="og:url" content="https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/"><meta property="og:type" content="website"><meta property="og:site_name" content="Just a dev blog"><meta name=twitter:title content="Multi-CPU Github Actions with Go"><meta name=twitter:description content="When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.101.0"><link rel=alternate href=https://blog.bswiecki.dev/index.xml type=application/rss+xml title="Just a dev blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://blog.bswiecki.dev/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://blog.bswiecki.dev/css/syntax.css><link rel=stylesheet href=https://blog.bswiecki.dev/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://blog.bswiecki.dev/>Just a dev blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=https://blog.bswiecki.dev/>Blog</a></li><li><a title=About href=https://blog.bswiecki.dev/page/about/>About</a></li><li><a title=Tags href=https://blog.bswiecki.dev/tags>Tags</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Multi-CPU Github Actions with Go</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on July 19, 2022
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Bartłomiej Święcki</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind -
the famous <a href=https://en.wikipedia.org/wiki/X86-64>x86-64</a> one. It is the main player on our desktops and on the server side.
Even more recent generation of game consoles switched to that architecture from
some more exotic ones.</p><p>But there are alternatives. Some are pretty well known such as the <a href=https://en.wikipedia.org/wiki/ARM_architecture_family>ARM</a> one
that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops).
But there are many more like <a href=https://en.wikipedia.org/wiki/RISC-V>RISC-V</a> or <a href=https://en.wikipedia.org/wiki/SPARC>SPARC</a>, each with special properties
and target group usually in the enterprise segment.</p><p>It is not a surprise that even newer languages such as <a href=https://go.dev>Go</a> support variety of CPU architectures.
A quick check on my local Go compiler reveals that the for the Linux OS itself it already
supports 12 CPU architectures:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ go tool dist list <span class=p>|</span> grep <span class=s1>&#39;^linux&#39;</span> <span class=p>|</span> wc -l
</span></span><span class=line><span class=cl><span class=m>12</span>
</span></span></code></pre></div><h2 id=automatic-builds-and-tests-with-github-actions>Automatic builds and tests with Github Actions</h2><p>I can&rsquo;t imagine high quality project without CI pipeline checking if the code works as expected.
With variety of tools and ready-to-use online services it&rsquo;s a must.
Like Github actions. Setting a Github project with Github Actions is really simple.
But if the target application should work on various CPU architectures,
there&rsquo;s not much physical hardware easily available that we could choose from for our test workflows.</p><p>Github currently offers only x86-64 machines (with Windows, Linux or MacOS)
which means that it will be hard to check if subtle CPU differences don&rsquo;t affect the behavior of our code.
Those could be as simple as some assumption about the size of the <code>int</code> type, hardcoded endianness or
different memory alignment.</p><h2 id=qemu-to-the-rescue>Qemu to the rescue</h2><p>Qemu is a well-known and established software emulating various CPU architectures.
And it turns out that it can easily be used to execute Linux binaries built for different CPU architectures.</p><p>Before we get into details, let me share a project where I demonstrate how it can be used: <a href=https://github.com/byo/multi-cpu-demo/actions>https://github.com/byo/multi-cpu-demo/actions</a>.
I created it to demonstrate application written in go that is compiled and tested on various CPU architectures.
The essence is in <a href=https://github.com/byo/multi-cpu-demo/blob/main/.github/workflows/test.yml>this workflow file</a>. Let&rsquo;s take a look at its most relevant sections.</p><h3 id=setting-up-qemu>Setting up qemu</h3><p>It turns out that there&rsquo;s already working Github action for that. Installing and setting up <code>qemu</code> for emulation is as simple as that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/setup-qemu-action@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></div><p>That <code>setup-qemu-action</code> step itself does all the trickery to ensure the correct <code>qemu</code> version is installed
and tightly integrated with the host (runner) operation system (more on that later).</p><h3 id=compiling-go-code-for-target-platform>Compiling go code for target platform</h3><p>Go compiler can easily generate binaries for various OSes and CPU architectures
no matter what the host OS and architecture the compiler runs on.</p><p>To switch to different CPU we only have to setup the <code>GOARCH</code> environment variables:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>go build -o hello .</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>GOARCH</span><span class=p>:</span><span class=w> </span><span class=l>arm</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></div><p>Changing the target operating system can be done in a very similar way - by setting the <code>GOOS</code> environment variable.
We won&rsquo;t be dealing with different OS-es though, only Linux this time 🐧😉.</p><h3 id=executing-binaries-with-emulation>Executing binaries with emulation</h3><p>This is something that I was really surprised with.
The <code>qemu</code> instance set up with <code>docker/setup-qemu-action@v2</code> is actually installed in a very clever way.
It does not simply install qemu binaries, actually I think it does not even copy a single binary to the host OS.
Instead it is using <a href=https://en.wikipedia.org/wiki/Binfmt_misc>binfmt_misc</a> kernel mechanism to integrate <code>qemu</code> as an emulator needed to run certain binaries -
in our case those are binary files for architecture other than the host system.
If we try to run binary not meant for the host CPU,
qemu takes over and does all the magic behind the scenes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>./hello</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></div><h3 id=running-go-tests-on-different-cpu-architecture>Running go tests on different CPU architecture</h3><p>The tight system integration of <code>qemu</code> has one more advantage.
It allows running <code>go</code> tests just as if we were running those on the host CPU:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>go test -v .</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>GOARCH</span><span class=p>:</span><span class=w> </span><span class=l>arm</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></div><p>How does it work then? Does it mean that we&rsquo;re running the go toolchain itself in <code>qemu</code>?</p><p>Well, not really. When the <code>go test</code> command is executed,
what it is actually doing is to compile a temporary binary from the test code and then executes it.</p><p>The <code>go</code> command itself is built for the host CPU which is <code>x86-64</code> in this case.
It first runs on the host CPU and starts the test compilation process -
and here the <code>GOARCH</code> environment variable jumps in.
The compiled temporary binary is built for the <code>GOARCH</code> target CPU architecture (<code>arm</code> in our example above).</p><p>When the <code>go</code> compiler tries then to execute that binary, <code>qemu</code> jumps in (through the tight integration with the host OS)
and thus the test itself runs on CPU emulated with <code>qemu</code>. For the <code>go</code> command this is totally transparent.</p><h2 id=trade-offs-and-gotchas>Trade-offs and gotchas</h2><p>With the presented method we can run binaries on variety of different CPU architectures.
But this does not use the OS emulation itself. The only thing we can change is the <code>GOARCH</code> variable
and the <code>GOOS</code> must be left as <code>linux</code>. This can usually be worked around by using VM emulation
or choosing different OS for the runner itself. There are cases like the <a href=https://en.wikipedia.org/wiki/Apple_M1>Apple M1</a> though
where I didn&rsquo;t find so far a reliable way to run tests without buying a dedicated hardware box.</p><p>Also keep in mind that CPU emulation is a very heavy process itself.
Binaries executed through emulation will run much slower than on the real hardware.
There could also be subtle differences between the real and the emulated CPU.</p><p>It&rsquo;s also possible that the emulation itself will contain bugs.
I experienced that myself before and even <a href=https://github.com/golang/go/issues/53797>posted a bogus bug report to the go compiler team</a>
only to figure out later that this was a bug in the qemu version that I was using.</p><p>Another fact worth mentioning here is that qemu does not emulate all CPU architectures supported by the go compiler
(take a look at <a href=https://github.com/byo/multi-cpu-demo/commit/f02266ad6d3a26860876323c78ab0e27d98145e5>this commit</a> from my example project).
This means that some less popular configurations will still need either manual testing or dedicated hardware.</p><div class=blog-tags><a href=https://blog.bswiecki.dev//tags/go/>go</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/howto/>howto</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/github/>github</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/til/>til</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/ops/>ops</a>&nbsp;
<a href=https://blog.bswiecki.dev//tags/qemu/>qemu</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://blog.bswiecki.dev/post/2019-07-14-k-dag-university/ data-toggle=tooltip data-placement=top title="K-DAG University">&larr; Previous Post</a></li></ul><div class=disqus-comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blogbswieckidev.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/byo title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/bswiecki title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://keybase.io/byo title=Keybase><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-keybase fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Bartłomiej Święcki
&nbsp;&bull;&nbsp;&copy;
2022
&nbsp;&bull;&nbsp;
<a href=https://blog.bswiecki.dev/>Just a dev blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.101.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script>
<script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script>
<script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=https://blog.bswiecki.dev/js/main.js></script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://blog.bswiecki.dev/js/load-photoswipe.js></script></body></html>