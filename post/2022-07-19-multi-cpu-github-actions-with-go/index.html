<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Multi-CPU Github Actions with Go | Just a dev blog</title><meta name=keywords content="go,howto,github,til,ops,qemu"><meta name=description content="When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops)."><meta name=author content><link rel=canonical href=https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/><link crossorigin=anonymous href=https://blog.bswiecki.dev/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://blog.bswiecki.dev/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.bswiecki.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.bswiecki.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.bswiecki.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.bswiecki.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.bswiecki.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Multi-CPU Github Actions with Go"><meta property="og:description" content="When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops)."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-07-19T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Multi-CPU Github Actions with Go"><meta name=twitter:description content="When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bswiecki.dev/post/"},{"@type":"ListItem","position":2,"name":"Multi-CPU Github Actions with Go","item":"https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Multi-CPU Github Actions with Go","name":"Multi-CPU Github Actions with Go","description":"When we think about CPU architecture usually there\u0026rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.\nBut there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops).","keywords":["go","howto","github","til","ops","qemu"],"articleBody":"When we think about CPU architecture usually there‚Äôs one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.\nBut there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops). But there are many more like RISC-V or SPARC, each with special properties and target group usually in the enterprise segment.\nIt is not a surprise that even newer languages such as Go support variety of CPU architectures. A quick check on my local Go compiler reveals that the for the Linux OS itself it already supports 12 CPU architectures:\n$ go tool dist list | grep '^linux' | wc -l 12 Automatic builds and tests with Github Actions I can‚Äôt imagine high quality project without CI pipeline checking if the code works as expected. With variety of tools and ready-to-use online services it‚Äôs a must. Like Github actions. Setting a Github project with Github Actions is really simple. But if the target application should work on various CPU architectures, there‚Äôs not much physical hardware easily available that we could choose from for our test workflows.\nGithub currently offers only x86-64 machines (with Windows, Linux or MacOS) which means that it will be hard to check if subtle CPU differences don‚Äôt affect the behavior of our code. Those could be as simple as some assumption about the size of the int type, hardcoded endianness or different memory alignment.\nQemu to the rescue Qemu is a well-known and established software emulating various CPU architectures. And it turns out that it can easily be used to execute Linux binaries built for different CPU architectures.\nBefore we get into details, let me share a project where I demonstrate how it can be used: https://github.com/byo/multi-cpu-demo/actions. I created it to demonstrate application written in go that is compiled and tested on various CPU architectures. The essence is in this workflow file. Let‚Äôs take a look at its most relevant sections.\nSetting up qemu It turns out that there‚Äôs already working Github action for that. Installing and setting up qemu for emulation is as simple as that:\n... jobs: test: runs-on: ubuntu-latest steps: ... - uses: docker/setup-qemu-action@v2 ... That setup-qemu-action step itself does all the trickery to ensure the correct qemu version is installed and tightly integrated with the host (runner) operation system (more on that later).\nCompiling go code for target platform Go compiler can easily generate binaries for various OSes and CPU architectures no matter what the host OS and architecture the compiler runs on.\nTo switch to different CPU we only have to setup the GOARCH environment variables:\n... jobs: test: runs-on: ubuntu-latest steps: ... - run: go build -o hello . env: GOARCH: arm ... Changing the target operating system can be done in a very similar way - by setting the GOOS environment variable. We won‚Äôt be dealing with different OS-es though, only Linux this time üêßüòâ.\nExecuting binaries with emulation This is something that I was really surprised with. The qemu instance set up with docker/setup-qemu-action@v2 is actually installed in a very clever way. It does not simply install qemu binaries, actually I think it does not even copy a single binary to the host OS. Instead it is using binfmt_misc kernel mechanism to integrate qemu as an emulator needed to run certain binaries - in our case those are binary files for architecture other than the host system. If we try to run binary not meant for the host CPU, qemu takes over and does all the magic behind the scenes:\n... jobs: test: runs-on: ubuntu-latest steps: ... - run: ./hello ... Running go tests on different CPU architecture The tight system integration of qemu has one more advantage. It allows running go tests just as if we were running those on the host CPU:\n... jobs: test: runs-on: ubuntu-latest steps: ... - run: go test -v . env: GOARCH: arm ... How does it work then? Does it mean that we‚Äôre running the go toolchain itself in qemu?\nWell, not really. When the go test command is executed, what it is actually doing is to compile a temporary binary from the test code and then executes it.\nThe go command itself is built for the host CPU which is x86-64 in this case. It first runs on the host CPU and starts the test compilation process and here the GOARCH environment variable jumps in. The compiled temporary binary is built for the GOARCH target CPU architecture (arm in our example above).\nWhen the go compiler tries then to execute that binary, qemu jumps in (through the tight integration with the host OS) and thus the test itself runs on CPU emulated with qemu. For the go command this is totally transparent.\nTrade-offs and gotchas With the presented method we can run binaries on variety of different CPU architectures. But this does not use the OS emulation itself. The only thing we can change is the GOARCH variable and the GOOS must be left as linux. This can usually be worked around by using VM emulation or choosing different OS for the runner itself. There are cases like the Apple M1 though where I didn‚Äôt find so far a reliable way to run tests without buying a dedicated hardware box.\nAlso keep in mind that CPU emulation is a very heavy process itself. Binaries executed through emulation will run much slower than on the real hardware. There could also be subtle differences between the real and the emulated CPU.\nIt‚Äôs also possible that the emulation itself will contain bugs. I experienced that myself before and even posted a bogus bug report to the go compiler team only to figure out later that this was a bug in the qemu version that I was using.\nAnother fact worth mentioning here is that qemu does not emulate all CPU architectures supported by the go compiler (take a look at this commit from my example project). This means that some less popular configurations will still need either manual testing or dedicated hardware.\n","wordCount":"1049","inLanguage":"en","datePublished":"2022-07-19T00:00:00Z","dateModified":"2022-07-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/"},"publisher":{"@type":"Organization","name":"Just a dev blog","logo":{"@type":"ImageObject","url":"https://blog.bswiecki.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bswiecki.dev/ accesskey=h title="Just a dev blog (Alt + H)">Just a dev blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.bswiecki.dev/ title=Blog><span>Blog</span></a></li><li><a href=https://blog.bswiecki.dev/page/about/ title=About><span>About</span></a></li><li><a href=https://blog.bswiecki.dev/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Multi-CPU Github Actions with Go</h1><div class=post-meta><span title='2022-07-19 00:00:00 +0000 UTC'>July 19, 2022</span></div></header><div class=post-content><p>When we think about CPU architecture usually there&rsquo;s one leader that comes to our mind - the famous <a href=https://en.wikipedia.org/wiki/X86-64>x86-64</a> one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.</p><p>But there are alternatives. Some are pretty well known such as the <a href=https://en.wikipedia.org/wiki/ARM_architecture_family>ARM</a> one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops). But there are many more like <a href=https://en.wikipedia.org/wiki/RISC-V>RISC-V</a> or <a href=https://en.wikipedia.org/wiki/SPARC>SPARC</a>, each with special properties and target group usually in the enterprise segment.</p><p>It is not a surprise that even newer languages such as <a href=https://go.dev>Go</a> support variety of CPU architectures. A quick check on my local Go compiler reveals that the for the Linux OS itself it already supports 12 CPU architectures:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ go tool dist list | grep <span style=color:#e6db74>&#39;^linux&#39;</span> | wc -l
</span></span><span style=display:flex><span><span style=color:#ae81ff>12</span>
</span></span></code></pre></div><h2 id=automatic-builds-and-tests-with-github-actions>Automatic builds and tests with Github Actions<a hidden class=anchor aria-hidden=true href=#automatic-builds-and-tests-with-github-actions>#</a></h2><p>I can&rsquo;t imagine high quality project without CI pipeline checking if the code works as expected. With variety of tools and ready-to-use online services it&rsquo;s a must. Like Github actions. Setting a Github project with Github Actions is really simple. But if the target application should work on various CPU architectures, there&rsquo;s not much physical hardware easily available that we could choose from for our test workflows.</p><p>Github currently offers only x86-64 machines (with Windows, Linux or MacOS) which means that it will be hard to check if subtle CPU differences don&rsquo;t affect the behavior of our code. Those could be as simple as some assumption about the size of the <code>int</code> type, hardcoded endianness or different memory alignment.</p><h2 id=qemu-to-the-rescue>Qemu to the rescue<a hidden class=anchor aria-hidden=true href=#qemu-to-the-rescue>#</a></h2><p>Qemu is a well-known and established software emulating various CPU architectures. And it turns out that it can easily be used to execute Linux binaries built for different CPU architectures.</p><p>Before we get into details, let me share a project where I demonstrate how it can be used: <a href=https://github.com/byo/multi-cpu-demo/actions>https://github.com/byo/multi-cpu-demo/actions</a>. I created it to demonstrate application written in go that is compiled and tested on various CPU architectures. The essence is in <a href=https://github.com/byo/multi-cpu-demo/blob/main/.github/workflows/test.yml>this workflow file</a>. Let&rsquo;s take a look at its most relevant sections.</p><h3 id=setting-up-qemu>Setting up qemu<a hidden class=anchor aria-hidden=true href=#setting-up-qemu>#</a></h3><p>It turns out that there&rsquo;s already working Github action for that. Installing and setting up <code>qemu</code> for emulation is as simple as that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>jobs</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>test</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>docker/setup-qemu-action@v2</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span></code></pre></div><p>That <code>setup-qemu-action</code> step itself does all the trickery to ensure the correct <code>qemu</code> version is installed and tightly integrated with the host (runner) operation system (more on that later).</p><h3 id=compiling-go-code-for-target-platform>Compiling go code for target platform<a hidden class=anchor aria-hidden=true href=#compiling-go-code-for-target-platform>#</a></h3><p>Go compiler can easily generate binaries for various OSes and CPU architectures no matter what the host OS and architecture the compiler runs on.</p><p>To switch to different CPU we only have to setup the <code>GOARCH</code> environment variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>jobs</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>test</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>go build -o hello .</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>GOARCH</span>: <span style=color:#ae81ff>arm</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span></code></pre></div><p>Changing the target operating system can be done in a very similar way - by setting the <code>GOOS</code> environment variable. We won&rsquo;t be dealing with different OS-es though, only Linux this time üêßüòâ.</p><h3 id=executing-binaries-with-emulation>Executing binaries with emulation<a hidden class=anchor aria-hidden=true href=#executing-binaries-with-emulation>#</a></h3><p>This is something that I was really surprised with. The <code>qemu</code> instance set up with <code>docker/setup-qemu-action@v2</code> is actually installed in a very clever way. It does not simply install qemu binaries, actually I think it does not even copy a single binary to the host OS. Instead it is using <a href=https://en.wikipedia.org/wiki/Binfmt_misc>binfmt_misc</a> kernel mechanism to integrate <code>qemu</code> as an emulator needed to run certain binaries - in our case those are binary files for architecture other than the host system. If we try to run binary not meant for the host CPU, qemu takes over and does all the magic behind the scenes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>jobs</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>test</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>./hello</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span></code></pre></div><h3 id=running-go-tests-on-different-cpu-architecture>Running go tests on different CPU architecture<a hidden class=anchor aria-hidden=true href=#running-go-tests-on-different-cpu-architecture>#</a></h3><p>The tight system integration of <code>qemu</code> has one more advantage. It allows running <code>go</code> tests just as if we were running those on the host CPU:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#f92672>jobs</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>test</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>run</span>: <span style=color:#ae81ff>go test -v .</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>GOARCH</span>: <span style=color:#ae81ff>arm</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>...</span>
</span></span></code></pre></div><p>How does it work then? Does it mean that we&rsquo;re running the go toolchain itself in <code>qemu</code>?</p><p>Well, not really. When the <code>go test</code> command is executed, what it is actually doing is to compile a temporary binary from the test code and then executes it.</p><p>The <code>go</code> command itself is built for the host CPU which is <code>x86-64</code> in this case. It first runs on the host CPU and starts the test compilation process and here the <code>GOARCH</code> environment variable jumps in. The compiled temporary binary is built for the <code>GOARCH</code> target CPU architecture (<code>arm</code> in our example above).</p><p>When the <code>go</code> compiler tries then to execute that binary, <code>qemu</code> jumps in (through the tight integration with the host OS) and thus the test itself runs on CPU emulated with <code>qemu</code>. For the <code>go</code> command this is totally transparent.</p><h2 id=trade-offs-and-gotchas>Trade-offs and gotchas<a hidden class=anchor aria-hidden=true href=#trade-offs-and-gotchas>#</a></h2><p>With the presented method we can run binaries on variety of different CPU architectures. But this does not use the OS emulation itself. The only thing we can change is the <code>GOARCH</code> variable and the <code>GOOS</code> must be left as <code>linux</code>. This can usually be worked around by using VM emulation or choosing different OS for the runner itself. There are cases like the <a href=https://en.wikipedia.org/wiki/Apple_M1>Apple M1</a> though where I didn&rsquo;t find so far a reliable way to run tests without buying a dedicated hardware box.</p><p>Also keep in mind that CPU emulation is a very heavy process itself. Binaries executed through emulation will run much slower than on the real hardware. There could also be subtle differences between the real and the emulated CPU.</p><p>It&rsquo;s also possible that the emulation itself will contain bugs. I experienced that myself before and even <a href=https://github.com/golang/go/issues/53797>posted a bogus bug report to the go compiler team</a> only to figure out later that this was a bug in the qemu version that I was using.</p><p>Another fact worth mentioning here is that qemu does not emulate all CPU architectures supported by the go compiler (take a look at <a href=https://github.com/byo/multi-cpu-demo/commit/f02266ad6d3a26860876323c78ab0e27d98145e5>this commit</a> from my example project). This means that some less popular configurations will still need either manual testing or dedicated hardware.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bswiecki.dev/tags/go/>go</a></li><li><a href=https://blog.bswiecki.dev/tags/howto/>howto</a></li><li><a href=https://blog.bswiecki.dev/tags/github/>github</a></li><li><a href=https://blog.bswiecki.dev/tags/til/>til</a></li><li><a href=https://blog.bswiecki.dev/tags/ops/>ops</a></li><li><a href=https://blog.bswiecki.dev/tags/qemu/>qemu</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.bswiecki.dev/>Just a dev blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><link href=https://blog.bswiecki.dev/css/mermaid.css type=text/css rel=stylesheet><script defer src=https://blog.bswiecki.dev/js/mermaid.js onload=mermaid.initialize({startOnLoad:!0})></script>
<link href=https://blog.bswiecki.dev/css/katex.css type=text/css rel=stylesheet><script defer src=https://blog.bswiecki.dev/js/katex.js></script>
<script defer src=https://blog.bswiecki.dev/js/katex-auto-render.js onload=renderMathInElement(document.body)></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>