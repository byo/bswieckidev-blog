<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Just a dev blog</title><link>https://blog.bswiecki.dev/</link><description>Recent content on Just a dev blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 18 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.bswiecki.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Quick way to combine io.Reader and io.Closer</title><link>https://blog.bswiecki.dev/post/2023-01-18-combining-reader-closer/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2023-01-18-combining-reader-closer/</guid><description>There are many interesting tools in Golang&amp;rsquo;s standard library to wrap io.Reader instance such as io.LimitedReader or cipher.StreamReader. But when wrapping a io.ReadCloser instance, the Close method is hidden.
Here&amp;rsquo;s a quick code snippet to combine wrapped io.Reader and the original io.Closer through an inline struct to rebuild the io.Closer interface.
Code var rc io.ReadCloser = struct { io.Reader io.Closer }{ Reader: r, Closer: c, } What it is about? The io.</description></item><item><title>Throttling Pool</title><link>https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/</link><pubDate>Tue, 22 Nov 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/</guid><description>In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves.</description></item><item><title>Throttling in Go</title><link>https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/</guid><description>Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&amp;rsquo;t have to deal with memory management, it has lightweight goroutines and we don&amp;rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server.</description></item><item><title>Multi-CPU Github Actions with Go</title><link>https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/</guid><description>When we think about CPU architecture usually there&amp;rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops).</description></item><item><title>K-DAG University</title><link>https://blog.bswiecki.dev/post/2019-07-14-k-dag-university/</link><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2019-07-14-k-dag-university/</guid><description>Last time I briefly described the knowledge in the form of a Graph structure. Each term having set of prerequisites is a node in this graph, each dependency is a directed edge in such graph.
Now let&amp;rsquo;s assume this graph is a directed acyclic one and there are no terms which form a cycle of dependencies. In reality I don&amp;rsquo;t believe this to be true but it does simplify reasoning and can definitely be achieved locally for larger terms.</description></item><item><title>Knowledge DAG</title><link>https://blog.bswiecki.dev/post/2019-07-10-knowledge-dag/</link><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2019-07-10-knowledge-dag/</guid><description>If I have some specific problem to solve, I find technology that seems relevant, then I scan the Internet for some basic introduction, then some tutorial, then documentation.
My usual problem is that the issue I want to solve is usually not in the introduction nor the tutorial. I rarely find ready-to-use solution and unfortunately I tend to really dislike adjusting my idea to what you can easily achieve with tutorial-like solutions.</description></item><item><title>Boot</title><link>https://blog.bswiecki.dev/post/2019-07-06-booting-up/</link><pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2019-07-06-booting-up/</guid><description>Yeah, one of the hardest things - materialize your thoughts.
We&amp;rsquo;re living in a world full of digital content. People write, produce, record, put so many things into the Internet that it&amp;rsquo;s very easy to just get lost in all this informational chaos. Will this blog share the same fate? Most likely, not going to lie here.
Honestly I&amp;rsquo;m not sure if the information I could throw into the big information highway will be that meaningful.</description></item><item><title>About this blog</title><link>https://blog.bswiecki.dev/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/page/about/</guid><description>This space is mostly a brain dump. I have few ideas I&amp;rsquo;d like to explore so why not do it in public.</description></item></channel></rss>