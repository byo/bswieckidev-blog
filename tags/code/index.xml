<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code on Just a dev blog</title><link>https://blog.bswiecki.dev/tags/code/</link><description>Recent content in code on Just a dev blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 22 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.bswiecki.dev/tags/code/index.xml" rel="self" type="application/rss+xml"/><item><title>Throttling Pool</title><link>https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/</link><pubDate>Tue, 22 Nov 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-11-22-throttling-pool/</guid><description>In my last post I presented few techniques useful for limiting simultaneous operations in Go. Such throttlers are indeed a very neat tools to keep our resources under control. However we can be extended that idea to even better tool for resource control when we mix throttlers with object pools.
Object pools in go Even though golang has a very efficient memory management system, there are some cases where we would like to manage the memory by ourselves.</description></item><item><title>Throttling in Go</title><link>https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/</guid><description>Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&amp;rsquo;t have to deal with memory management, it has lightweight goroutines and we don&amp;rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server.</description></item></channel></rss>