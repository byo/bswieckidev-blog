<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Just a dev blog</title><link>https://blog.bswiecki.dev/tags/go/</link><description>Recent content in go on Just a dev blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 07 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.bswiecki.dev/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Throttling in Go</title><link>https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-10-07-throttling-in-go/</guid><description>Go language makes a good job at making hard things simple. It compiles the code so that it runs fast, it comes with garbage collector so we don&amp;rsquo;t have to deal with memory management, it has lightweight goroutines and we don&amp;rsquo;t have to think a lot about concurrency limits. And in majority of cases all those language constructs combined with sane defaults will be good enough. Just like writing a web server.</description></item><item><title>Multi-CPU Github Actions with Go</title><link>https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.bswiecki.dev/post/2022-07-19-multi-cpu-github-actions-with-go/</guid><description>When we think about CPU architecture usually there&amp;rsquo;s one leader that comes to our mind - the famous x86-64 one. It is the main player on our desktops and on the server side. Even more recent generation of game consoles switched to that architecture from some more exotic ones.
But there are alternatives. Some are pretty well known such as the ARM one that took over the mobile market (and slowly enters the desktop world with Apple M1 laptops).</description></item></channel></rss>